---
title: "Metrics on CCI"
format: html
warning: false
message: false
# html standalone
standalone: true
editor: 
  markdown: 
    wrap: 72
    
---

## libraries

load a few libraries

```{r}
library(dplyr)
library(tidyr)
library(ggplot2)
library(lubridate)
library(ggthemes)
library(sf)
library(ggspatial)
library(viridis)
library(raster)
library(stringr)
library(pracma)
library(purrr)
library(Rcpp)
library(multidplyr)
#library(data.table)
library("dbscan")

library(factoextra)
library(cluster)
library(ClustGeo)
```


definisco il fattore di riduzione spaziale
il fattore di ricampionamento per lo smooth
il numero di campioni di bootstrap

```{r}
myfactor <- 4
myfact_smooth <- 4
nboot <- 100

```



```{r}


dt <- readRDS(here::here("data", "06.3_metrics_NOTrel_DT.rds"))

```

```{r}

dt2 <- dt |> 
	  dplyr::select( -year) |>
  # replace - inf with 0
  mutate(across(everything(), ~if_else(. == -Inf, 0, .))) |>
  # replace na with 0
  mutate(across(everything(), ~if_else(is.na(.), 0, .))) |> 
  # scalec
  mutate(across(everything(), scale)) 


  cor(dt2, use = "pairwise.complete.obs")
corrplot::corrplot(cor(dt2, use = "pairwise.complete.obs"), method = "circle", type = "upper", tl.col = "black", tl.srt = 45)


# quali variabili hanno una correlazione pià alta di 0.85
cor <- cor(dt2, use = "pairwise.complete.obs")
cor <- as.data.frame(as.table(cor))
cor <- cor |> 
  filter(Freq > 0.85) |> 
  arrange(desc(Freq)) |> 
  filter(Var1 != Var2)

cor

```


rimuovo:

CHL_mean_last_35
mx
end_doy


uso un dataset a più bassa risoluzione


```{r}

# rimuovo le variabili correlate
dt2 <- dt2 |> 
  dplyr::select(-CHL_mean_last_35, -mx, -end_doy)


rfull <- rasterFromXYZ(dt2)
rfull

myfact <-myfactor

# aggregate factor 8
r8 <- aggregate(rfull, fact = myfact, fun = mean)
mask <- r8[[1]]
maskNA <- mask

values(mask)[!is.na(values(mask))] <- 1

values(r8)[which(is.na(values(r8)))] <- 0

plot(r8)

```




https://github.com/MatthieuStigler/Misc/blob/master/spatial/spatial_segmentation_field_GeoClust_demo.md



## K selection
https://statsandr.com/blog/clustering-analysis-k-means-and-hierarchical-clustering-by-hand-and-in-r/


```{r}

dist_rast_euclid <-  function(x)  {
  x %>% 
    xyFromCell(cell = 1:ncell(.))  %>% 
    dist() 
}



hclustgeo_df <-  function(D0, D1 = NULL, alpha, n_obs = TRUE, k = K) {
  res <- hclustgeo(D0, D1, alpha = alpha) %>% 
    cutree(k=k) %>% 
    tibble(cluster = .)
  if(n_obs) res <-  res %>% 
      mutate(n_obs =   1:nrow(.)) %>% 
      dplyr::select(n_obs, everything())
  res
  
}

```


distances

```{r}
dat_dist <- dist(getValues(r8))
geo_dist <-  dist_rast_euclid(r8)
```


valuto solo le variabili fenologiche 
(https://hal.science/hal-01664018/document)
```{r}
myclust <- hclustgeo(dat_dist)


plot(myclust, hang=-1,label=FALSE, xlab="",sub="", main="")


length(which(myclust$height>0.1))

       height <- data.frame(h = myclust$height, id = 1:length(myclust$height))
       
       hplot <- height |> 
         filter(h > 0.1)

barplot(hplot$h,
  names.arg = nrow(hplot):1 # show the number of cluster below each bars
)
```











```{r}
hclusCut <- function(x, k, d.meth = "euclidean", ...)    list(cluster = cutree(hclust(dist(x, method=d.meth), ...), k=k))


hc_geo <- function(x, k, d.meth = "euclidean", ...)    list(cluster = cutree(hclustgeo(dist(x)), k=k))


#gskmn <- clusGap(getValues(r8), FUN = hclusCut, K.max = 20, B = 5, method = "Tibs2001SEmax")

gskmn <- clusGap(getValues(r8), FUN = hc_geo,  K.max = 28, B = nboot, method = "Tibs2001SEmax")

plot(gskmn)

fviz_gap_stat(gskmn, maxSE = list(method = "Tibs2001SEmax"))
gskmn
 print(gskmn, method = "Tibs2001SEmax")
 print(gskmn, method = "firstSEmax")

str(summary(gskmn))




# Tibshirani
gap_values <- gskmn$Tab[, "gap"]
se_values <- gskmn$Tab[, "SE.sim"]
optimal_k <- 1
for (k in 1:(length(gap_values) - 1)) {
  if (gap_values[k] >= gap_values[k + 1] - se_values[k + 1]) {
    optimal_k <- k
    break
  }
}

# Stampare il numero ottimale di cluster
print(optimal_k)
Tibs <- optimal_k


# Trovare il primo massimo locale
max_gap <- max(gap_values)
first_max_loc <- which.max(gap_values)
SE.factor <- 1

# Trova il primo massimo locale del Gap Statistic
max_local_gap <- which(diff(sign(diff(gap_values))) == -2) + 1
if (length(max_local_gap) == 0) {
  max_local_gap <- 1
}

# Applicare il criterio "firstSEmax"
optimal_k <- 1
for (k in max_local_gap:length(gap_values)) {
  if (gap_values[k] >= gap_values[max_local_gap] - SE.factor * se_values[max_local_gap]) {
    optimal_k <- k
    break
  }
}

# Stampare il numero ottimale di cluster
print(optimal_k)


print(paste(
  "Tipshirani: optimal number of clusters is:",
  Tibs,
  "; the FirstSEmax criterion suggests:",
  optimal_k
  
))

selK <- max(Tibs)
selK
```



```{r}
ras_dat <- as.data.frame(r8, xy = TRUE) %>%  as_tibble %>% 
  mutate(n_cell = 1:ncell(r8)) %>% 
  dplyr::select(n_cell, everything())# %>% 
  #rename(value = layer)

```



```{r}

alphaS <- c(
  c(0, 0.1, 0.2, 0.5, 0.6, 0.7, 0.8,  1),
  seq(0.3, 0.4, by = 0.025)
)

alphaS <- alphaS |> sort()



K <- selK


cr <- choicealpha(dat_dist, geo_dist, , K = K, range.alpha = alphaS, graph=TRUE)
plot(cr, norm = T)

alphaSEL <-  alphaS[which.min(abs(cr$Qnorm[, 1] - cr$Qnorm[,2]))] 
alphaSEL

res_alphas <- data_frame(alpha = alphaS) %>% 
  mutate(alpha_name = paste("alpha", alpha, sep="_"),
         data = map(alpha, ~ hclustgeo_df(dat_dist, geo_dist,alpha = ., K)))



res_alphas_l <-  res_alphas %>% 
  unnest(data) %>% 
  left_join(ras_dat, by = c("n_obs" = "n_cell")) %>% 
  mutate_at(c("alpha", "cluster"), as.factor) 

```


```{r}

res_alphas_l_dat <-  res_alphas_l %>% 
  filter(alpha %in% alphaS) 


pl_clus_geoSpace <- res_alphas_l_dat %>% 
  ggplot(aes(x = x, y= y, fill = factor(cluster))) +
  geom_tile() + 
  facet_grid(alpha ~ .) +
  theme(legend.position = "none") +
  ggtitle("Cluster, in geo-space") +
  theme_few()

pl_clus_geoSpace

saveRDS(res_alphas_l_dat, here::here("out", paste0("06.4.4_res_alphas_l_dat_f", myfactor, "_k", K, ".rds")))

```



# raster

```{r}
selex <- res_alphas_l_dat |> 
  filter(alpha == alphaSEL[1] )

clustR <- rasterFromXYZ(selex[c("x", "y", "cluster")])
plot(clustR)
writeRaster(clustR, here::here("out", paste0("06.4.4_bioregion_COARSE", myfactor, "_k", K,  "nBoot_", nboot,  ".tif")), overwrite = TRUE)



res_high <- res(clustR) / myfact_smooth  # Ad esempio, dimezza la risoluzione per aumentare i dettagli
clustR_high_res <- resample(clustR, raster(extent(clustR), resolution=res_high), method = "ngb")
clustR_smooth <- focal(clustR_high_res, w = matrix(1, 15, 15), fun = median)
writeRaster(clustR_smooth, here::here("out", paste0("06.4.4_bioregion_smooth_f", myfactor, "_k", K, "res_", myfact_smooth, "nBoot_", nboot,  ".tif")), overwrite = TRUE)


plot(clustR)
plot(clustR_smooth)


pol <- rasterToPolygons(clustR_smooth) |> st_as_sf() |> 
  group_by(layer) |>
  summarise(geometry = st_union(geometry)) 

plot(pol)
st_write(pol, here::here("out",  paste0("06.4.4_bioregion_smooth_f",  myfactor, "_k", K, "res_", myfact_smooth, "nBoot_", nboot, ".shp")), overwrite = TRUE, append=FALSE)





```





<!-- # con climatologia -->
<!-- "D:\Dropbox\R_projects\SV_phenology\data\CDS\daily_smoothed\daily_smoothed.nc" -->

<!-- ```{r} -->
<!-- rfull <- stack(here::here("data", "CDS/daily_smoothed/daily_smoothed.nc")) -->
<!-- rfull -->

<!-- rdf <- as.data.frame(rfull, xy = TRUE) %>%  as_tibble %>%  -->
<!--   # replace NA with 0 fol all variables -->
<!--   mutate_at(vars(-x, -y), ~ replace_na(., 0))  -->

<!-- rfull <- rasterFromXYZ(rdf) -->


<!-- # aggregate factor 8 -->
<!-- r8 <- aggregate(rfull, fact = myfact, fun = mean) -->

<!-- plot(r8[[40:50]]) -->

<!-- ``` -->





<!-- https://github.com/MatthieuStigler/Misc/blob/master/spatial/spatial_segmentation_field_GeoClust_demo.md -->



<!-- ## K selection -->
<!-- https://statsandr.com/blog/clustering-analysis-k-means-and-hierarchical-clustering-by-hand-and-in-r/ -->




<!-- distances -->

<!-- ```{r} -->
<!-- dat_dist <- dist(getValues(r8)) -->
<!-- geo_dist <-  dist_rast_euclid(r8) -->
<!-- ``` -->


<!-- valuto solo le variabili fenologiche  -->
<!-- (https://hal.science/hal-01664018/document) -->
<!-- ```{r} -->
<!-- myclust <- hclustgeo(dat_dist) -->
<!-- plot(myclust, hang=-1,label=FALSE, xlab="",sub="", main="") -->

<!-- length(which(myclust$height>0.1)) -->

<!--        height <- data.frame(h = myclust$height, id = 1:length(myclust$height)) -->

<!--        hplot <- height |>  -->
<!--          filter(h > 0.1) -->

<!-- barplot(hplot$h, -->
<!--   names.arg = nrow(hplot):1 # show the number of cluster below each bars -->
<!-- ) -->
<!-- ``` -->






<!-- ```{r} -->
<!-- si3 <- silhouette(cutree(myclust, k = 5), # k = 4 gave the same as pam() above -->
<!--     	           dat_dist) -->

<!-- summary(si3)$avg.width -->



<!-- sil <- data.frame(k = NA, avg.width = NA)[0, ] -->

<!-- for( i in 2:45){ -->
<!--   si <- silhouette(cutree(myclust, k = i), dat_dist) -->


<!--   # Calcolare il WSS -->
<!--   sil <- rbind(sil, data.frame(k = i, avg.width = summary(si)$avg.width)) -->
<!-- } -->


<!-- ggplot(sil, aes(k, avg.width)) + -->
<!--   geom_point() + -->
<!--   geom_hline(yintercept = mean(sil$avg.width), linetype = "dashed")  -->

<!-- range.alpha <- seq(0,1,0.1) -->
<!-- K <- 12 -->
<!-- cr <- choicealpha(dat_dist, geo_dist,range.alpha,K,graph=TRUE) -->
<!-- cr$Q -->
<!-- cr$Qnorm -->

<!-- ``` -->


<!-- ```{r} -->
<!-- ras_dat <- as.data.frame(r8, xy = TRUE) %>%  as_tibble %>%  -->
<!--   mutate(n_cell = 1:ncell(r8)) %>%  -->
<!--   dplyr::select(n_cell, everything())# %>%  -->
<!--   #rename(value = layer) -->
<!-- ras_dat -->
<!-- ``` -->


<!-- ```{r} -->
<!-- res_alphas <- data_frame(alpha = seq(0, 1, by = 0.1)) %>%  -->
<!--   mutate(alpha_name = paste("alpha", alpha, sep="_"), -->
<!--          data = map(alpha, ~ hclustgeo_df(dat_dist, geo_dist,alpha = ., 12))) -->



<!-- res_alphas_l <-  res_alphas %>%  -->
<!--   unnest(data) %>%  -->
<!--   left_join(ras_dat, by = c("n_obs" = "n_cell")) %>%  -->
<!--   mutate_at(c("alpha", "cluster"), as.factor)  -->

<!-- ``` -->


<!-- ```{r} -->

<!-- res_alphas_l_dat <-  res_alphas_l %>%  -->
<!--   filter(alpha %in% c(0, 0.1, 0.3, 0.4, 0.8, 0.9, 1))  -->


<!-- pl_clus_geoSpace <- res_alphas_l_dat %>%  -->
<!--   ggplot(aes(x = x, y= y, fill = factor(cluster))) + -->
<!--   geom_tile() + -->
<!--   facet_grid(alpha ~ .) + -->
<!--   theme(legend.position = "none") + -->
<!--   ggtitle("Cluster, in geo-space") + -->
<!--   theme_few() -->

<!-- pl_clus_geoSpace -->
<!-- ``` -->


